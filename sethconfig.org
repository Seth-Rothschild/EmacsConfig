#+TITLE: Seth Rothschild's Emacs Configuration 
#+OPTIONS: toc:2 h:4
<<babel-init>>

I use emacs as most of my operating system. As such, the
packages and code here has been built up around the way that
I work. That means that this is probably not a useful
configuration for you: if you're a new user this contains
code you don't need and if you're an experienced user you
have your own way of doing things.

This is my third version of my init file, but the first that
I'm using with =org-babel= and the first that I'm uploading
to Github. In my previous iteration I was using evil mode
extensively. To replace that, I'm experimenting with hydra
and key-chord as found here.

The overall structure is based on the excellent
formatting in [[http://sachachua.com/dotemacs][Sacha Chua's Emacs Configuration]]. 
This code is not yet ready to function as my init file. When
it is up to speed and clean I can include the line

=(org-babel-load-file (expand-file-name "sethconfig.org" user-emacs-directory))=

* Configuration
This file is broken into two parts. The first section is my
current configuration which in the future will be fairly
stable. The second section should be functions and packages
that I'm not sure I want to incorporate into my workflow.
That way the "things I might delete" sections can stay away
from the stable sections.

** Starting up
The first order of business is modifying my load-path and
exec-path to include melpa and things I've installed through
homebrew. Modifying =custom-file= means that emacs doesn't
try to write the customize settings into this file.
#+begin_src emacs-lisp :tangle yes
(require 'package)
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(package-initialize)             

(add-to-list 'exec-path "/usr/local/bin/")
(add-to-list 'exec-path "/usr/bin/")
(add-to-list 'load-path "/usr/share/emacs/24.3/lisp")

(setq custom-file "~/.emacs.d/custom-settings.el")
(load custom-file t)

(require 'use-package)
(server-start)
#+end_src

*** Secrets
So that I can display this publically, I've moved personal
information to another file. That file is loaded here.
#+begin_src emacs-lisp :tangle yes
  (load-file "~/.emacs.d/personal.el")
#+end_src

** Appearance 
Fill column is set small right now. If I end up liking margin changes
which are currently experimental, I might not need it quite
so small.

This section is mostly "common sense" changes for how I
expected emacs to act. I've turned off the bell, changed to
=y-or-n= and disabled automatic indenting. 
#+begin_src emacs-lisp :tangle yes
(require 'recentf)
(which-key-mode)
(require 'dired-x)

(setq-default fill-column 60)
(setq column-number-mode t)
(electric-indent-mode 0)
(defalias 'yes-or-no-p 'y-or-n-p)
(setq ring-bell-function 'ignore)
(setq sentence-end-double-space nil)   

(setq read-buffer-completion-ignore-case t)
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq recentf-max-saved-items 150)
#+end_src
I use dired-x to clean up my =.tex= folders and make them a
little easier to read from emacs. The only thing I might
want to see again are files that begin with a dot, so I
might modify this later.  
#+begin_src emacs-lisp :tangle yes
(setq default-directory "~/")
(setq dired-omit-files 
  (concat dired-omit-files
    "\\|^\\..+$\\|^.
    +?\\.aux$\\|^.
    +?\\.log$\\|^.
    +?sync\\|^.
    +?out\\|^.
    +?run.xml")
)
                         
(add-hook 'dired-mode-hook
  (lambda ()
    (dired-omit-mode 1)
))

(global-unset-key (kbd "M-o"))
(global-set-key (kbd "M-o") 'dired-omit-mode)

(global-unset-key (kbd "C-l"))
(global-set-key (kbd "C-l") 'dired-up-directory)

;; Found on http://jblevins.org/log/dired-open
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map (kbd "z")
       (lambda () (interactive)
         (let ((fn (dired-get-file-for-visit)))
           (start-process "default-app" nil "open" fn))))))
#+end_src
** Movement
*** Helm
These replace the ordinary emacs functions with their =helm=
counterparts. I completely bypassed these while using evil
mode. I'm going to attempt to do something similar with
=hydra= below. 

Of the helm functions below, =helm-show-kill-ring= might be
one of the only keybindings I use. I'd also like to
incorporate =helm-swoop= but I'm unsure about it still.
#+begin_src emacs-lisp :tangle yes
(require 'helm)
(require 'helm-config)
(helm-mode 1)

(setq helm-split-window-in-side-p       t 
  helm-move-to-line-cycle-in-source     t 
  helm-ff-search-library-in-sexp        t 
  helm-scroll-amount                    8 
  helm-ff-file-name-history-use-recentf t
)
(helm-autoresize-mode t)
(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) 
(define-key helm-map (kbd "C-z")  'helm-select-action) 

(global-set-key (kbd "C-c h") 'helm-command-prefix)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
#+end_src
*** Hydra
This is moving in the right direction, though I think the hydra body keybinding for windows and spacehydra might change. 
Structurally, I think this is more or less
how I want it set up. I need
+ Movement commands inside of a window 
+ Movement commands between windows
+ Functions where I need easy access 
Something I didn't expect to be fundamental was that the keybinding all overlap. That is, it turned out to be important that I could get from spacehydra to movement commands and back easily. Open questions:

1. There's currently some weirdness around using q as an escape key.
2. Is it important to have a newline above and below command?
3. What commands would be unobtrusive for windows and space?
     
#+begin_src emacs-lisp :tangle yes
(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

(defhydra nomodifier-movement ()
  "Emacs Movement"
  ("a" beginning-of-line)
  ("A" backward-sentence)
  ("b" backward-char)
  ("B" backward-word)
  ("dl" delete-char)
  ("dw" kill-word)
  ("dd" kill-whole-line)
  ("dr" kill-region)
  ("e" end-of-line)
  ("E" forward-sentence)
  ("f" forward-char)
  ("F" forward-word)
  ("n" next-line)
  ("N" (next-line 5))
  ("p" previous-line)
  ("P" (previous-line 5))
  ("u" undo-tree-undo)
  ("U" undo-tree-visualize)
  ("v" set-mark-command)
  ("V" select-current-line)
  ("x" delete-char)
  ("X" delete-backward-char)
  ("y" yank)
  ("SPC" spacehydra/body :exit t)
  ("q" nil)
)

(defhydra window-movement ()
  "Window Movement"
  ("<left>" windmove-left)
  ("<right>" windmove-right)
  ("<down>" windmove-down)
  ("<up>" windmove-up)
  ("b" helm-mini)
  ("B" (progn (other-window 1) (helm-mini)))
  ("d" delete-window)
  ("D" delete-other-windows)
  ("f" find-file)
  ("F" find-file-other-window)
  ("o" other-window)
  ("v" split-window-right)
  ("SPC" spacehydra/body :exit t)
  ("n" nomodifier-movement/body :exit t)
  ("p" nomodifier-movement/body :exit t)
  ("q" nil)
)


(defhydra spacehydra (:exit t)
  "Space-Hydra"
  ("a" org-agenda "agenda")
  ("b" helm-mini)
  ("c" org-capture "capture")
  ("d" dired) 
  ("fa" helm-ag "helm-ag")
  ("ff" helm-find-files)
  ("hf" describe-function)
  ("hi" info)
  ("hk" describe-key)
  ("hm" describe-mode)
  ("hv" describe-variable)
  ("ls" org-store-link "store link")
  ("li" org-insert-link "insert link")
  ("n" nomodifier-movement/body :exit t)
  ("o" window-movement/body :exit t)
  ("p" nomodifier-movement/body :exit t)
  ("s" save-buffer "save")
  ("t" (find-file (TODO-file-today)) "todo")
  ("m" magit-status "magit status")
  ("x" helm-M-x)
  ("q" nil)
)

(key-chord-mode 1)
(key-chord-define-global "np" 'nomodifier-movement/body)

(global-unset-key (kbd "C-o")) 
(global-set-key (kbd "C-o") 'window-movement/body)

(key-chord-define-global "  " 'spacehydra/body)

#+end_src
Additionally, I'll set up some Hydras for modes that I use regularly. For =org-mode= I'll want some global commands and some local commands. It is still unclear if I prefer having org-global commands in their own hydra. The local commands should be mostly the same as my movement commands with some extras for org mode. Is there a way to extend a hydra in a certain mode?

#+begin_src emacs-lisp :tangle yes
(defhydra orghydra-local ()
   "Hydra for org movement"
  ("a" beginning-of-line)
  ("A" backward-sentence)
  ("b" backward-char)
  ("B" backward-word)
  ("dl" delete-char)
  ("dw" kill-word)
  ("dd" kill-whole-line)
  ("dr" kill-region)
  ("e" end-of-line)
  ("E" forward-sentence)
  ("f" forward-char)
  ("F" forward-word)
  ("n" next-line)
  ("N" (next-line 5))
  ("p" previous-line)
  ("P" (previous-line 5))
  ("u" undo-tree-undo)
  ("U" undo-tree-visualize)
  ("v" set-mark-command)
  ("V" select-current-line)
  ("x" delete-char)
  ("X" delete-backward-char)
  ("y" yank) 
  
  ("il" (progn (newline)
    (insert-string "<s")
    (org-try-structure-completion)
    (insert-string "emacs-lisp :tangle yes")
    (next-line)
  ) "insert lisp block")
  ("t" org-todo "org-todo")
  ("." org-time-stamp "org-time-stamp")
  ("<left>" org-metaleft)
  ("<right>" org-metaright)
  ("<up>" org-metaup)
  ("<down>" org-metadown)
  ("<tab>" org-cycle)
  ("SPC" spacehydra/body :exit t)
  ("q" nil)
)

(key-chord-define org-mode-map "np" 'orghydra-local/body)
(setq org-return-follows-link t)
#+end_src 
** Packages
*** AucTeX 
This is not yet up to date or clean.
#+begin_src emacs-lisp :tangle yes
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (setq reftex-plug-into-AUCTeX t)
  (setq TeX-PDF-mode t)
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook
    (lambda () (local-set-key (kbd "<M-S-mouse-1>") #'TeX-view))
  )
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
  
  (getenv "PATH")
  (setenv "PATH" (concat "/usr/texbin" ":"
      (getenv "PATH")
    )
  )
  (getenv "PATH")
  
  (setenv "PATH" (concat "/usr/local/bin" ":"
      (getenv "PATH")
    )
  )
  (setenv "PATH" (concat "/usr/bin" ":"
      (getenv "PATH")
    )
  )
  
  (setq TeX-source-correlate-method 'synctex)
  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))

  (setq TeX-view-program-list '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b %n %o %b")))
  (add-hook 'LaTeX-mode-hook 
    (lambda()
      (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
      (setq TeX-save-query nil)
      (setq TeX-show-compilation nil)
    )
  )

  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
#+end_src
*** GAP
GAP and Pari are here for the same reason, would it be
reasonable for them to be in the same subsection?
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload 'gap-mode "gap-mode" "Gap editing mode" t)
  (setq auto-mode-alist (append (list '("\\.g$" . gap-mode)
    '("\\.gap$" . gap-mode))
    auto-mode-alist))
  (autoload 'gap "gap-process" "Run GAP in emacs buffer" t)
  (setq gap-executable "/Users/seth/Downloads/gap4r8/bin/gap-default64.sh")
  (setq gap-start-options '("-n" "-f" "-b" "-m" "2g"))
#+END_SRC
*** GP/Pari
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "/usr/local/bin/pari")
  (autoload 'gp-mode "pari" nil t)
  (autoload 'gp-script-mode "pari" nil t)
  (autoload 'gp "pari" nil t)
  (autoload 'gpman "pari" nil t)
  (setq auto-mode-alist (cons '("\\.gp$" . gp-script-mode)
    auto-mode-alist))
#+END_SRC
*** Jabber 
#+begin_src emacs-lisp :tangle yes
  (require 'jabber)
  (setq 
    jabber-roster-line-format " %c %-25n %u %-8s"
    jabber-chat-buffer-show-avatar nil
    jabber-history-enabled t
    jabber-use-global-history t
    jabber-backlog-number 40
    jabber-backlog-days 30
  )
#+end_src
*** Magit
#+begin_src emacs-lisp :tangle yes
(setq magit-repository-directories '("~/Desktop/Repositories"))
#+end_src
*** Multiple Cursors 
#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
#+end_src
*** Twitter
#+begin_src emacs-lisp :tangle yes
  (require 'twittering-mode)
  (defun twitter-open-link ()
    (twittering-goto-next-thing t)
    (twittering-enter)
  )
  (if twittering-mode-map
    (let ((km twittering-mode-map))
      (define-key km (kbd "n") 'twittering-goto-next-status)
      (define-key km (kbd "p") 'twittering-goto-previous-status)
      (define-key km (kbd "N") 'twittering-goto-next-status-of-user)
      (define-key km (kbd "P") 'twittering-goto-previous-status-of-user)
      (define-key km (kbd "o") 'twitter-open-link)
      nil
    )
  )
#+end_src
** Lisp
From [[wikemacs.org/wiki/Emacs_Lisp_Cookbook]]:
#+begin_src emacs-lisp :tangle yes
(defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-current-buffer (find-file-noselect file)
      (buffer-string)))
#+end_src
Make a box around a title:
#+begin_src emacs-lisp :tangle yes
(defun boxify ()
  (interactive)
  (beginning-of-line)
  (newline)
  (previous-line)
  (insert "+------------------------------")
  (next-line)
  (beginning-of-line)
  (insert "|  ")
  (end-of-line)
  (insert "  |")
  (newline)
  (insert "+------------------------------")
  (previous-line 1)
  (previous-line 1)  
  (backward-char)
  (kill-line)
  (insert "+")
  (next-line 2)
  (backward-char)
  (kill-line)
  (insert "+")
)
#+end_src
Kill the mu4e update process when it gets stuck. Figuring
out /why/ it gets stuck is a problem for another day...
#+begin_src emacs-lisp :tangle yes
(defun mu4e-kill-update-process ()
  (interactive)
  (kill-process " *mu4e-update*")
)
#+end_src
** Mu4e
My configuration for mu4e is extensive. One advantage of
moving this configuration to =org= is that I can put the
entirety of this configuration into the same file and then
hide the subtree. This section needs cleaning.
#+begin_src emacs-lisp :tangle yes
  
  (setq mu4e-maildir "~/Maildir")
  
  (setq mu4e-drafts-folder "/Gmail/[Gmail].Drafts")
  (setq mu4e-sent-folder   "/Gmail/[Gmail].Sent Mail")
  (setq mu4e-trash-folder  "/Gmail/[Gmail].Trash")
  
  (setq mu4e-sent-messages-behavior 'sent)
  
  (setq mu4e-maildir-shortcuts
      '( ("/Gmail/INBOX"     . ?i)
         ("/Outlook/INBOX"   . ?e)))
  
  ;; allow for updating mail using 'U' in the main view:
  (setq mu4e-get-mail-command "/usr/local/bin/offlineimap")
  (setq mu4e-update-interval 180)
  (setq mu4e-split-view 'horizontal)
  (setq mu4e-headers-visible-lines 14)
  
  (setq mu4e-headers-fields
      '( (:human-date    .  12)
         (:flags         .   6)
         (:from          .  22)
         (:to            .  22)
         (:subject       .  nil)))
  
  (add-to-list 'mu4e-bookmarks
  '("\"maildir:/Gmail/[Gmail].Sent Mail\" date:8w..now OR \"maildir:/Outlook/Sent\" date:8w..now" "All sent" ?s))
  (add-to-list 'mu4e-bookmarks
  	     '("\"maildir:/Gmail/INBOX\" date:4w..now OR \"maildir:/Outlook/INBOX\" date:4w..now" "All mail" ?a))
  
  
   
  ;; something about ourselves
  
  (setq message-signature nil)
  (setq message-signature-file "~/.emacs.d/.signature")
  (setq mu4e-compose-signature-auto-include nil)
  (setq mu4e-compose-signature (file-string "~/.emacs.d/.signature"))
  (setq mu4e-compose-dont-reply-to-self t)
  
  (setq starttls-gnutls-program "/usr/local/bin/gnutls-cli")
  
  (require 'smtpmail)
  
  (setq message-kill-buffer-on-exit t)
  
  (defun my-mu4e-set-account ()
    "Set the account for composing a message."
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var))
                                                  my-mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                               nil t nil nil (caar my-mu4e-account-alist))))
           (account-vars (cdr (assoc account my-mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars)
        (error "No email account found"))))
  
  (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
  (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)
  
  (require 'gnus-dired)

  (defun gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
  	(set-buffer buffer)
  	(when (and (derived-mode-p 'message-mode)
  	  (null message-sent-message-via))
  	  (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  
  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
  
  (require 'org-mu4e)
  
  (add-to-list 'mu4e-view-actions
    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  (add-to-list 'helm-find-files-actions
    '("Attach files for mu4e" .
      helm-mu4e-attach) t
  )
  
  (defun helm-mu4e-attach (_file)
    (gnus-dired-attach (helm-marked-candidates)))
  (require 'helm-mu)
  (setq mu4e-hide-index-messages 1)
  
  (mu4e-alert-set-default-style 'notifier)
  (setq alert-notifier-command "/usr/local/bin/terminal-notifier")
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
  
  
  (require 'mu4e-contrib) 
  (setq mu4e-html2text-command 'mu4e-shr2text) 
#+end_src
** Org
General configuration: Not yet done and not yet clean. Org mode hydra defined above.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-capture-templates '(
    ("t" "TODO capture"
         entry (file (TODO-file-today))
         "* TODO %?")
    ("l" "TODO capture with link"
         entry (file (TODO-file-today))
         "* TODO %?\n  From: %a")
))

(setq org-cycle-emulate-tab nil)
(setq org-directory "~/.emacs.d/org-files")
(setq org-agenda-files (file-expand-wildcards "~/.emacs.d/org-files/*.org"))
#+END_SRC
I find that I like making throwaway todo lists when I have a lot of things that need doing. I've tried an overarching org setup in the past but it seems to not stick. Instead of trying that again, I'm going to try to enhance the habits I tend towards naturally.

Here I only have two captures: a TODO without a link and a TODO with one. The first two functions are slightly modified from [[http://www.howardism.org/Technical/Emacs/journaling-org.html]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun get-TODO-file-today ()
  "Return filename for today's journal entry."
  (let ((daily-name (format-time-string "%Y-%m-%d")))
    (expand-file-name (concat "~/.emacs.d/org-files/" daily-name ".org"))))

(defun TODO-file-today ()
  "Create and load a journal file based on today's date."
  (if (equal (file-exists-p (get-TODO-file-today)) t)
    (get-TODO-file-today)
    (progn
      (find-file (get-TODO-file-today))
      (insert-string (concat "#+TITLE: TODO List for " (format-time-string "%A, %B %d")))
      (newline)
      (insert-string "#+DATE: ")
      (org-date-from-calendar)
      (save-buffer t)
      (get-TODO-file-today)
    )
  )
)
#+END_SRC

* Elisp for testing
I haven't yet decided if I'll use these, so I'll keep them
here until I either find a home for them or delete them.
** Undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC
** Helm swoop
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-swoop
  :bind
  ("C-s" . helm-swoop)
  :config
  (progn
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
)
#+END_SRC
** Reading
From [[http:ergoemacs.com/emacs/emacs_make_modern.html]]

This is clearly a step in the right direction. Maybe I need
to look more into this with =visual-line-mode= so that I can
stop filling everything with =M-q=.
#+begin_src emacs-lisp :tangle yes
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0) ) )
#+end_src
