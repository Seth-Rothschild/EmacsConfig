#+TITLE: Seth Rothschild's Emacs Configuration 
#+OPTIONS: toc:2 h:4
<<babel-init>>

I use emacs as most of my operating system. As such, the
packages and code here has been built up around the way that
I work. That means that this is probably not a useful
configuration for you: if you're a new user this contains
code you don't need and if you're an experienced user you
have your own way of doing things.

This is my third version of my init file, but the first that
I'm using with =org-babel= and the first that I'm uploading
to Github. In my previous iteration I was using evil mode
extensively. To replace that, I'm experimenting with hydra
and key-chord as found here.

The overall structure is based on the excellent formatting
in [[http://sachachua.com/dotemacs][Sacha Chua's Emacs Configuration]]. It is called when emacs starts by the line
=(org-babel-load-file (expand-file-name "sethconfig.org" user-emacs-directory))=
in my init file. That command creates the =sethconfig.el= file.

* Configuration
This configuration is broken into two parts. The first
section is my current configuration which in the future will
be fairly stable. The second section should be functions and
packages that I'm not sure I want to incorporate into my
workflow. For one time testing of elisp I use the scratch
buffer.

** Starting up
The first order of business is modifying my load-path and
exec-path to include melpa and things I've installed through
homebrew. I hadn't considered modifying =custom-file=, but
I've really liked it since it keeps the clutter out of this
file.

#+begin_src emacs-lisp :tangle yes
(require 'package)
(add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/"))
(package-initialize)             

(add-to-list 'exec-path "/usr/local/bin/")
(add-to-list 'exec-path "/usr/bin/")
(add-to-list 'load-path "/usr/share/emacs/24.3/lisp")

(setq custom-file "~/.emacs.d/custom-settings.el")
(load custom-file t)

(require 'use-package)
(server-start)

;; I use the server so that I can open applications with emacsclient without
;; running the entire init file again. In automator, I exported
;; for f in "$@"
;;  do
;;	/usr/local/bin/emacsclient -a "" -n "$f"
;;  done
;; as EmacsClient.app, and set that as the default application to open things
#+end_src

*** Secrets
So that I can display this publically, I've moved personal
information to another file. That file is loaded here.
#+begin_src emacs-lisp :tangle yes
  (load-file "~/.emacs.d/personal.el")
#+end_src

** Appearance 
Fill column is set small right now. If I end up liking margin changes
which are currently experimental, I might not need it quite
so small.

This section is mostly "common sense" changes for how I
expected emacs to act. I've turned off the bell, changed to
=y-or-n= and disabled automatic indenting. 
#+begin_src emacs-lisp :tangle yes
(require 'recentf)
(which-key-mode)
(require 'dired-x)

(setq-default fill-column 60)

(setq column-number-mode t)
(electric-indent-mode 0)
(defalias 'yes-or-no-p 'y-or-n-p)
(setq ring-bell-function 'ignore)
(setq sentence-end-double-space nil)   

(setq read-buffer-completion-ignore-case t)
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq recentf-max-saved-items 150)
#+end_src
I use dired-x to clean up my =.tex= folders and make them a
little easier to read from emacs. The only thing I might
want to see again are files that begin with a dot, so I
might modify this later.  
#+begin_src emacs-lisp :tangle yes
(setq default-directory "~/")
(setq dired-omit-files 
  (concat dired-omit-files
    "\\|^\\..+$\\|^.
    +?\\.aux$\\|^.
    +?\\.log$\\|^.
    +?sync\\|^.
    +?out\\|^.
    +?run.xml")
)
                         
(add-hook 'dired-mode-hook
  (lambda ()
    (dired-omit-mode 1)
))

(global-unset-key (kbd "M-o"))
(global-set-key (kbd "M-o") 'dired-omit-mode)

(global-unset-key (kbd "C-l"))
(global-set-key (kbd "C-l") 'dired-up-directory)

;; Found on http://jblevins.org/log/dired-open
(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map (kbd "z")
       (lambda () (interactive)
         (let ((fn (dired-get-file-for-visit)))
           (start-process "default-app" nil "open" fn))))))
#+end_src
** Movement
*** Helm
These replace the ordinary emacs functions with their =helm=
counterparts. I completely bypassed these keybindings while
using evil mode and will do the same with =hydra= below.

Of the helm functions, =helm-show-kill-ring= and =helm-M-X= might be
the only keybindings I use. I'd also like to
incorporate =helm-swoop= but I'm unsure about it still.
#+begin_src emacs-lisp :tangle yes
(require 'helm)
(require 'helm-config)
(helm-mode 1)

(setq helm-split-window-in-side-p       t 
  helm-move-to-line-cycle-in-source     t 
  helm-ff-search-library-in-sexp        t 
  helm-scroll-amount                    8 
  helm-ff-file-name-history-use-recentf t
)
(helm-autoresize-mode t)

(define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) 
(define-key helm-map (kbd "C-z")  'helm-select-action) 

(global-set-key (kbd "C-x b") 'helm-mini)
(global-set-key (kbd "C-x C-f") 'helm-find-files)
(global-set-key (kbd "C-c h") 'helm-command-prefix)

(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
#+end_src
*** Hydra
This is moving in the right direction, though I think the
hydra body keybinding for windows and spacehydra might
change. Structurally, I think this is more or less how I
want it set up. I need
+ Movement commands inside of a window 
+ Movement commands between windows
+ Functions where I need easy access 
Something I didn't expect to be fundamental was that the keybinding all overlap. That is, it turned out to be important that I could get from spacehydra to movement commands and back easily. Open questions:

1. There's currently some weirdness around using q as an escape key.
2. Is it important to have a newline above and below command?
3. What commands would be unobtrusive for windows and space?
     
#+begin_src emacs-lisp :tangle yes
(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

(defhydra nomodifier-movement ()
   "Movement Hydra"
  ("a" beginning-of-line)
  ("A" backward-sentence)
  ("b" backward-char)
  ("B" backward-word)
  ("dl" delete-char)
  ("dw" kill-word)
  ("dd" kill-whole-line)
  ("dr" kill-region)
  ("e" end-of-line)
  ("E" forward-sentence)
  ("f" forward-char)
  ("F" forward-word)
  ("n" next-line)
  ("N" (next-line 5))
  ("p" previous-line)
  ("P" (previous-line 5))
  ("u" undo-tree-undo)
  ("U" undo-tree-visualize)
  ("v" set-mark-command)
  ("V" select-current-line)
  ("x" delete-char)
  ("X" delete-backward-char)
  ("y" yank) 
  
  ("il" (progn (newline)
    (insert-string "<s")
    (org-try-structure-completion)
    (insert-string "emacs-lisp :tangle yes")
    (next-line)
  ))
  ("t" org-todo)
  ("." org-time-stamp)
  ("<left>" org-metaleft)
  ("<right>" org-metaright)
  ("<up>" org-metaup)
  ("<down>" org-metadown)
  ("<tab>" org-cycle)

  ("cc" TeX-command-master)
  ("cv" TeX-view)
  ("ce" LaTeX-environment)
  ("cs" LaTeX-section)
  
  ("o" window-movement/body :exit t)
  ("SPC" spacehydra-movement/body :exit t)
  ("q" nil)
)

(setq nomodifier-movement/hint
  '(prog1 (eval (hydra--format nil '(nil nil :hint nil) "\n" nomodifier-movement/heads))
    (define-key nomodifier-movement/keymap "a" 'nomodifier-movement/beginning-of-line)
    (define-key nomodifier-movement/keymap "A" 'nomodifier-movement/backward-sentence)
    (define-key nomodifier-movement/keymap "b" 'nomodifier-movement/backward-char)
    (define-key nomodifier-movement/keymap "B" 'nomodifier-movement/backward-word)
    (define-key nomodifier-movement/keymap "dl" 'nomodifier-movement/delete-char)
    (define-key nomodifier-movement/keymap "dw" 'nomodifier-movement/kill-word)
    (define-key nomodifier-movement/keymap "dd" 'nomodifier-movement/kill-whole-line)
    (define-key nomodifier-movement/keymap "dr" 'nomodifier-movement/kill-region)
    (define-key nomodifier-movement/keymap "e" 'nomodifier-movement/end-of-line)
    (define-key nomodifier-movement/keymap "E" 'nomodifier-movement/forward-sentence)
    (define-key nomodifier-movement/keymap "f" 'nomodifier-movement/forward-char)
    (define-key nomodifier-movement/keymap "F" 'nomodifier-movement/forward-word)
    (define-key nomodifier-movement/keymap "n" 'nomodifier-movement/next-line)
    (define-key nomodifier-movement/keymap "N" 'nomodifier-movement/lambda-N)
    (define-key nomodifier-movement/keymap "p" 'nomodifier-movement/previous-line)
    (define-key nomodifier-movement/keymap "P" 'nomodifier-movement/lambda-P)
    (define-key nomodifier-movement/keymap "u" 'nomodifier-movement/undo-tree-undo)
    (define-key nomodifier-movement/keymap "U" 'nomodifier-movement/undo-tree-visualize)
    (define-key nomodifier-movement/keymap "v" 'nomodifier-movement/set-mark-command)
    (define-key nomodifier-movement/keymap "V" 'nomodifier-movement/select-current-line)
    (define-key nomodifier-movement/keymap "x" 'nomodifier-movement/delete-char)
    (define-key nomodifier-movement/keymap "X" 'nomodifier-movement/delete-backward-char)
    (define-key nomodifier-movement/keymap "y" 'nomodifier-movement/yank) 

    (define-key nomodifier-movement/keymap "o" 'nomodifier-movement/window-movement/body-and-exit)
    (define-key nomodifier-movement/keymap "SPC" 'nomodifier-movement/spacehydra-movement/body-and-exit)
    (define-key nomodifier-movement/keymap "q" nil)    

    (if (equal major-mode 'org-mode)
      (progn
        (define-key nomodifier-movement/keymap "il" 'nomodifier-movement/lambda-il)
        (define-key nomodifier-movement/keymap "t" 'nomodifier-movement/org-todo)
        (define-key nomodifier-movement/keymap "." 'nomodifier-movement/org-time-stamp)
        (define-key nomodifier-movement/keymap "<left>" 'nomodifier-movement/org-metaleft)
        (define-key nomodifier-movement/keymap "<right>" 'nomodifier-movement/org-metaright)
        (define-key nomodifier-movement/keymap "<up>" 'nomodifier-movement/org-metaup)
        (define-key nomodifier-movement/keymap "<down>" 'nomodifier-movement/org-metadown)
        (define-key nomodifier-movement/keymap "<tab>" 'nomodifier-movement/org-cycle)
      )
      (progn
        (define-key nomodifier-movement/keymap "il" nil)
        (define-key nomodifier-movement/keymap "t" nil)
        (define-key nomodifier-movement/keymap "." nil)
        (define-key nomodifier-movement/keymap "<left>" nil)
        (define-key nomodifier-movement/keymap "<right>" nil)
        (define-key nomodifier-movement/keymap "<up>" nil)
        (define-key nomodifier-movement/keymap "<down>" nil)
        (define-key nomodifier-movement/keymap "<tab>" nil)
      )
    )
    (if (equal major-mode 'latex-mode)
      (progn
        (define-key nomodifier-movement/keymap "cc" 'nomodifier-movement/TeX-command-master)
        (define-key nomodifier-movement/keymap "cv" 'nomodifier-movement/Tex-view)
        (define-key nomodifier-movement/keymap "ce" 'nomodifier-movement/LaTeX-environment)
        (define-key nomodifier-movement/keymap "cs" 'nomodifier-movement/LaTeX-section)
      )
      (progn
        (define-key nomodifier-movement/keymap "cc" nil)
        (define-key nomodifier-movement/keymap "cv" nil)
        (define-key nomodifier-movement/keymap "ce" nil)
        (define-key nomodifier-movement/keymap "cs" nil)
      )
    )
  )
)

(defhydra window-movement ()
  "Window Movement"
  ("<left>" windmove-left)
  ("<right>" windmove-right)
  ("<down>" windmove-down)
  ("<up>" windmove-up)
  ("b" helm-mini)
  ("B" (progn (other-window 1) (helm-mini)))
  ("d" delete-window)
  ("D" delete-other-windows)
  ("f" find-file)
  ("F" find-file-other-window)
  ("h" split-window-below)
  ("o" other-window)
  ("v" split-window-right)

  ("SPC" spacehydra-movement/body :exit t)
  ("n" nomodifier-movement/body :exit t)
  ("p" nomodifier-movement/body :exit t)
  ("q" nil)
)


(defhydra spacehydra-movement (:exit t)
  "Space-Hydra"
  ("a" org-agenda "agenda")
  ("b" helm-mini)
  ("c" org-capture "capture")
  ("d" dired) 
  ("fa" helm-ag "helm-ag")
  ("ff" helm-find-files)
  ("hf" describe-function)
  ("hi" info)
  ("hk" describe-key)
  ("hm" describe-mode)
  ("hv" describe-variable)
  ("ls" org-store-link "store link")
  ("li" org-insert-link "insert link")
  ("s" save-buffer "save")
  ("t" (find-file (TODO-file-today)) "todo")
  ("m" magit-status "magit status")
  ("x" helm-M-x)

  ("n" nomodifier-movement/body :exit t)
  ("p" nomodifier-movement/body :exit t)
  ("o" window-movement/body :exit t)

  ("q" nil)
)

(key-chord-mode 1)
(key-chord-define-global "np" 'nomodifier-movement/body)

(global-unset-key (kbd "C-x o")) 
(global-set-key (kbd "C-x o") 'window-movement/body)

(key-chord-define-global "  " 'spacehydra-movement/body)

#+end_src


#+end_src 
** Packages
*** AucTeX 
This is not yet up to date or clean.
#+begin_src emacs-lisp :tangle yes
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (setq reftex-plug-into-AUCTeX t)
  (setq TeX-PDF-mode t)
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook
    (lambda () (local-set-key (kbd "<M-S-mouse-1>") #'TeX-view))
  )
  (add-hook 'LaTeX-mode-hook 'TeX-source-correlate-mode)
  
  (getenv "PATH")
  (setenv "PATH" (concat "/usr/texbin" ":"
      (getenv "PATH")
    )
  )
  (getenv "PATH")
  
  (setenv "PATH" (concat "/usr/local/bin" ":"
      (getenv "PATH")
    )
  )
  (setenv "PATH" (concat "/usr/bin" ":"
      (getenv "PATH")
    )
  )
  
  (setq TeX-source-correlate-method 'synctex)
  (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))

  (setq TeX-view-program-list '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b %n %o %b")))
  (add-hook 'LaTeX-mode-hook 
    (lambda()
      (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t))
      (setq TeX-save-query nil)
      (setq TeX-show-compilation nil)
    )
  )

  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
#+end_src
*** GAP
GAP and Pari are here for the same reason, would it be
reasonable for them to be in the same subsection?
#+BEGIN_SRC emacs-lisp :tangle yes
  (autoload 'gap-mode "gap-mode" "Gap editing mode" t)
  (setq auto-mode-alist (append (list '("\\.g$" . gap-mode)
    '("\\.gap$" . gap-mode))
    auto-mode-alist))
  (autoload 'gap "gap-process" "Run GAP in emacs buffer" t)
  (setq gap-executable "/Users/seth/Downloads/gap4r8/bin/gap-default64.sh")
  (setq gap-start-options '("-n" "-f" "-b" "-m" "2g"))
#+END_SRC
*** GP/Pari
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "/usr/local/bin/pari")
  (autoload 'gp-mode "pari" nil t)
  (autoload 'gp-script-mode "pari" nil t)
  (autoload 'gp "pari" nil t)
  (autoload 'gpman "pari" nil t)
  (setq auto-mode-alist (cons '("\\.gp$" . gp-script-mode)
    auto-mode-alist))
#+END_SRC
*** Jabber 
#+begin_src emacs-lisp :tangle yes
  (require 'jabber)
  (setq 
    jabber-roster-line-format " %c %-25n %u %-8s"
    jabber-chat-buffer-show-avatar nil
    jabber-history-enabled t
    jabber-use-global-history t
    jabber-backlog-number 40
    jabber-backlog-days 30
  )
#+end_src
*** Magit
#+begin_src emacs-lisp :tangle yes
(setq magit-repository-directories '("~/Desktop/Repositories"))
#+end_src
*** Multiple Cursors 
#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
#+end_src
*** Twitter
#+begin_src emacs-lisp :tangle yes
  (require 'twittering-mode)
  (defun twitter-open-link ()
    (twittering-goto-next-thing t)
    (twittering-enter)
  )
  (if twittering-mode-map
    (let ((km twittering-mode-map))
      (define-key km (kbd "n") 'twittering-goto-next-status)
      (define-key km (kbd "p") 'twittering-goto-previous-status)
      (define-key km (kbd "N") 'twittering-goto-next-status-of-user)
      (define-key km (kbd "P") 'twittering-goto-previous-status-of-user)
      (define-key km (kbd "o") 'twitter-open-link)
      nil
    )
  )
#+end_src
** Lisp
From [[wikemacs.org/wiki/Emacs_Lisp_Cookbook]]:
#+begin_src emacs-lisp :tangle yes
(defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-current-buffer (find-file-noselect file)
      (buffer-string)))
#+end_src
Make a box around a title:
#+begin_src emacs-lisp :tangle yes
(defun boxify ()
  (interactive)
  (beginning-of-line)
  (newline)
  (previous-line)
  (insert "+------------------------------")
  (next-line)
  (beginning-of-line)
  (insert "|  ")
  (end-of-line)
  (insert "  |")
  (newline)
  (insert "+------------------------------")
  (previous-line 1)
  (previous-line 1)  
  (backward-char)
  (kill-line)
  (insert "+")
  (next-line 2)
  (backward-char)
  (kill-line)
  (insert "+")
)
#+end_src
Kill the mu4e update process when it gets stuck. Figuring
out /why/ it gets stuck is a problem for another day...
#+begin_src emacs-lisp :tangle yes
(defun mu4e-kill-update-process ()
  (interactive)
  (kill-process " *mu4e-update*")
)
#+end_src
** Mu4e
My configuration for mu4e is extensive. One advantage of
moving this configuration to =org= is that I can put the
entirety of this configuration into the same file and then
hide the subtree. This section needs cleaning.
#+begin_src emacs-lisp :tangle yes
  
  (setq mu4e-maildir "~/Maildir")
  
  (setq mu4e-drafts-folder "/Gmail/[Gmail].Drafts")
  (setq mu4e-sent-folder   "/Gmail/[Gmail].Sent Mail")
  (setq mu4e-trash-folder  "/Gmail/[Gmail].Trash")
  
  (setq mu4e-sent-messages-behavior 'sent)
  
  (setq mu4e-maildir-shortcuts
      '( ("/Gmail/INBOX"     . ?i)
         ("/Outlook/INBOX"   . ?e)))
  
  ;; allow for updating mail using 'U' in the main view:
  (setq mu4e-get-mail-command "/usr/local/bin/offlineimap")
  (setq mu4e-update-interval 180)
  (setq mu4e-split-view 'horizontal)
  (setq mu4e-headers-visible-lines 14)
  
  (setq mu4e-headers-fields
      '( (:human-date    .  12)
         (:flags         .   6)
         (:from          .  22)
         (:to            .  22)
         (:subject       .  nil)))
  
  (add-to-list 'mu4e-bookmarks
  '("\"maildir:/Gmail/[Gmail].Sent Mail\" date:8w..now OR \"maildir:/Outlook/Sent\" date:8w..now" "All sent" ?s))
  (add-to-list 'mu4e-bookmarks
  	     '("\"maildir:/Gmail/INBOX\" date:4w..now OR \"maildir:/Outlook/INBOX\" date:4w..now" "All mail" ?a))
  
  
   
  ;; something about ourselves
  
  (setq message-signature nil)
  (setq message-signature-file "~/.emacs.d/.signature")
  (setq mu4e-compose-signature-auto-include nil)
  (setq mu4e-compose-signature (file-string "~/.emacs.d/.signature"))
  (setq mu4e-compose-dont-reply-to-self t)
  
  (setq starttls-gnutls-program "/usr/local/bin/gnutls-cli")
  
  (require 'smtpmail)
  
  (setq message-kill-buffer-on-exit t)
  
  (defun my-mu4e-set-account ()
    "Set the account for composing a message."
    (let* ((account
            (if mu4e-compose-parent-message
                (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                  (string-match "/\\(.*?\\)/" maildir)
                  (match-string 1 maildir))
              (completing-read (format "Compose with account: (%s) "
                                       (mapconcat #'(lambda (var) (car var))
                                                  my-mu4e-account-alist "/"))
                               (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                               nil t nil nil (caar my-mu4e-account-alist))))
           (account-vars (cdr (assoc account my-mu4e-account-alist))))
      (if account-vars
          (mapc #'(lambda (var)
                    (set (car var) (cadr var)))
                account-vars)
        (error "No email account found"))))
  
  (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
  (add-hook 'mu4e-compose-mode-hook 'flyspell-mode)
  
  (require 'gnus-dired)

  (defun gnus-dired-mail-buffers ()
    "Return a list of active message buffers."
    (let (buffers)
      (save-current-buffer
        (dolist (buffer (buffer-list t))
  	(set-buffer buffer)
  	(when (and (derived-mode-p 'message-mode)
  	  (null message-sent-message-via))
  	  (push (buffer-name buffer) buffers))))
      (nreverse buffers)))
  
  (setq gnus-dired-mail-mode 'mu4e-user-agent)
  (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode)
  
  (require 'org-mu4e)
  
  (add-to-list 'mu4e-view-actions
    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
  (add-to-list 'helm-find-files-actions
    '("Attach files for mu4e" .
      helm-mu4e-attach) t
  )
  
  (defun helm-mu4e-attach (_file)
    (gnus-dired-attach (helm-marked-candidates)))
  (require 'helm-mu)
  (setq mu4e-hide-index-messages 1)
  
  (mu4e-alert-set-default-style 'notifier)
  (setq alert-notifier-command "/usr/local/bin/terminal-notifier")
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
  
  
  (require 'mu4e-contrib) 
  (setq mu4e-html2text-command 'mu4e-shr2text) 
#+end_src
** Org
General configuration: Not yet done and not yet clean. Org mode hydra defined above.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq org-capture-templates '(
    ("t" "TODO capture"
         entry (file (TODO-file-today))
         "* TODO %?")
    ("l" "TODO capture with link"
         entry (file (TODO-file-today))
         "* TODO %?\n  From: %a")
))

(setq org-return-follows-link t)
(setq org-cycle-emulate-tab nil)
(setq org-directory "~/.emacs.d/org-files")
(setq org-agenda-files (file-expand-wildcards "~/.emacs.d/org-files/*.org"))

(setq org-todo-keywords
  '((sequence "TODO" "|" "WAIT" "DONE")))
(setq org-todo-keyword-faces
  '(("TODO" . org-warning) ("WAIT" . "blue")))
#+END_SRC
I find that I like making throwaway todo lists when I have a lot of things that need doing. I've tried an overarching org setup in the past but it seems to not stick. Instead of trying that again, I'm going to try to enhance the habits I tend towards naturally.

Here I only have two captures: a TODO without a link and a TODO with one. The first two functions are slightly modified from [[http://www.howardism.org/Technical/Emacs/journaling-org.html]]
#+BEGIN_SRC emacs-lisp :tangle yes
(defun get-TODO-file-today ()
  "Return filename for today's journal entry."
  (let ((daily-name (format-time-string "%Y-%m-%d")))
    (expand-file-name (concat "~/.emacs.d/org-files/" daily-name ".org"))))

(defun TODO-file-today ()
  "Create and load a journal file based on today's date."
  (if (equal (file-exists-p (get-TODO-file-today)) t)
    (get-TODO-file-today)
    (progn
      (calendar)
      (find-file (get-TODO-file-today))
      (insert-string (concat "#+TITLE: TODO List for " (format-time-string "%A, %B %d")))
      (newline)
      (insert-string "#+DATE: ")
      (org-date-from-calendar)
      (save-buffer t)
      (setq org-agenda-files (file-expand-wildcards "~/.emacs.d/org-files/*.org"))
      (get-TODO-file-today)
    )  
  )
)
#+END_SRC

* Elisp for testing
I haven't yet decided if I'll use these, so I'll keep them
here until I either find a home for them or delete them.
** Undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :diminish undo-tree-mode
  :config
  (progn
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t)))
#+END_SRC
** Helm swoop
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helm-swoop
  :bind
  ("C-s" . helm-swoop)
  :config
  (progn
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
)
#+END_SRC
** Reading
From [[http:ergoemacs.com/emacs/emacs_make_modern.html]]

This is clearly a step in the right direction. Maybe I need
to look more into this with =visual-line-mode= so that I can
stop filling everything with =M-q=.
#+begin_src emacs-lisp :tangle yes
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0) ) )
#+end_src
** Conditional Hydra
The goal is to have a /single/ hydra for movement which has different commands based on environment. Something like this will work: can define the actual keys for the given commands as the hint for the hydra in a massive conditional statement.
#+BEGIN_SRC emacs-lisp :tangle yes
(defhydra nomodifier-movement ()
   "Movement Hydra"
  ("a" beginning-of-line)
  ("A" backward-sentence)
  ("b" backward-char)
  ("B" backward-word)
  ("dl" delete-char)
  ("dw" kill-word)
  ("dd" kill-whole-line)
  ("dr" kill-region)
  ("e" end-of-line)
  ("E" forward-sentence)
  ("f" forward-char)
  ("F" forward-word)
  ("n" next-line)
  ("N" (next-line 5))
  ("p" previous-line)
  ("P" (previous-line 5))
  ("u" undo-tree-undo)
  ("U" undo-tree-visualize)
  ("v" set-mark-command)
  ("V" select-current-line)
  ("x" delete-char)
  ("X" delete-backward-char)
  ("y" yank) 
  
  ("il" (progn (newline)
    (insert-string "<s")
    (org-try-structure-completion)
    (insert-string "emacs-lisp :tangle yes")
    (next-line)
  ))
  ("t" org-todo)
  ("." org-time-stamp)
  ("<left>" org-metaleft)
  ("<right>" org-metaright)
  ("<up>" org-metaup)
  ("<down>" org-metadown)
  ("<tab>" org-cycle)

  ("cc" TeX-command-master)
  ("cv" TeX-view)
  ("ce" LaTeX-environment)
  ("cs" LaTeX-section)
  
  ("o" window-movement/body :exit t)
  ("SPC" spacehydra-movement/body :exit t)
  ("q" nil)
)

(setq nomodifier-movement/hint
  '(prog1 (eval (hydra--format nil '(nil nil :hint nil) "\n" nomodifier-movement/heads))
    (define-key nomodifier-movement/keymap "a" 'nomodifier-movement/beginning-of-line)
    (define-key nomodifier-movement/keymap "A" 'nomodifier-movement/backward-sentence)
    (define-key nomodifier-movement/keymap "b" 'nomodifier-movement/backward-char)
    (define-key nomodifier-movement/keymap "B" 'nomodifier-movement/backward-word)
    (define-key nomodifier-movement/keymap "dl" 'nomodifier-movement/delete-char)
    (define-key nomodifier-movement/keymap "dw" 'nomodifier-movement/kill-word)
    (define-key nomodifier-movement/keymap "dd" 'nomodifier-movement/kill-whole-line)
    (define-key nomodifier-movement/keymap "dr" 'nomodifier-movement/kill-region)
    (define-key nomodifier-movement/keymap "e" 'nomodifier-movement/end-of-line)
    (define-key nomodifier-movement/keymap "E" 'nomodifier-movement/forward-sentence)
    (define-key nomodifier-movement/keymap "f" 'nomodifier-movement/forward-char)
    (define-key nomodifier-movement/keymap "F" 'nomodifier-movement/forward-word)
    (define-key nomodifier-movement/keymap "n" 'nomodifier-movement/next-line)
    (define-key nomodifier-movement/keymap "N" 'nomodifier-movement/lambda-N)
    (define-key nomodifier-movement/keymap "p" 'nomodifier-movement/previous-line)
    (define-key nomodifier-movement/keymap "P" 'nomodifier-movement/lambda-P)
    (define-key nomodifier-movement/keymap "u" 'nomodifier-movement/undo-tree-undo)
    (define-key nomodifier-movement/keymap "U" 'nomodifier-movement/undo-tree-visualize)
    (define-key nomodifier-movement/keymap "v" 'nomodifier-movement/set-mark-command)
    (define-key nomodifier-movement/keymap "V" 'nomodifier-movement/select-current-line)
    (define-key nomodifier-movement/keymap "x" 'nomodifier-movement/delete-char)
    (define-key nomodifier-movement/keymap "X" 'nomodifier-movement/delete-backward-char)
    (define-key nomodifier-movement/keymap "y" 'nomodifier-movement/yank) 

    (define-key nomodifier-movement/keymap "o" 'nomodifier-movement/window-movement/body-and-exit)
    (define-key nomodifier-movement/keymap "SPC" 'nomodifier-movement/spacehydra-movement/body-and-exit)
    (define-key nomodifier-movement/keymap "q" nil)    

    (if (equal major-mode 'org-mode)
      (progn
        (define-key nomodifier-movement/keymap "il" 'nomodifier-movement/lambda-il)
        (define-key nomodifier-movement/keymap "t" 'nomodifier-movement/org-todo)
        (define-key nomodifier-movement/keymap "." 'nomodifier-movement/org-time-stamp)
        (define-key nomodifier-movement/keymap "<left>" 'nomodifier-movement/org-metaleft)
        (define-key nomodifier-movement/keymap "<right>" 'nomodifier-movement/org-metaright)
        (define-key nomodifier-movement/keymap "<up>" 'nomodifier-movement/org-metaup)
        (define-key nomodifier-movement/keymap "<down>" 'nomodifier-movement/org-metadown)
        (define-key nomodifier-movement/keymap "<tab>" 'nomodifier-movement/org-cycle)
      )
      (progn
        (define-key nomodifier-movement/keymap "il" nil)
        (define-key nomodifier-movement/keymap "t" nil)
        (define-key nomodifier-movement/keymap "." nil)
        (define-key nomodifier-movement/keymap "<left>" nil)
        (define-key nomodifier-movement/keymap "<right>" nil)
        (define-key nomodifier-movement/keymap "<up>" nil)
        (define-key nomodifier-movement/keymap "<down>" nil)
        (define-key nomodifier-movement/keymap "<tab>" nil)
      )
    )
    (if (equal major-mode 'latex-mode)
      (progn
        (define-key nomodifier-movement/keymap "cc" 'nomodifier-movement/TeX-command-master)
        (define-key nomodifier-movement/keymap "cv" 'nomodifier-movement/Tex-view)
        (define-key nomodifier-movement/keymap "ce" 'nomodifier-movement/LaTeX-environment)
        (define-key nomodifier-movement/keymap "cs" 'nomodifier-movement/LaTeX-section)
      )
      (progn
        (define-key nomodifier-movement/keymap "cc" nil)
        (define-key nomodifier-movement/keymap "cv" nil)
        (define-key nomodifier-movement/keymap "ce" nil)
        (define-key nomodifier-movement/keymap "cs" nil)
      )
    )
  )
)
#+END_SRC
